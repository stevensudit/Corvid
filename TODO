1. Do all the TODO's scattered throughout the code.
a. Interval needs a major rewrite.
c. concat_join has lots to do. and conversion.h has a related change.
e. string.h has some TODO's.
f. bitmask_enum_tests has some.
g. meta_test has a whole section commented out.
h. strings_test needs more tests.

2. Consider how ostream could be made optional.

3. We need a verson of split that understands quotes and escaping. Maybe just regex and be done with it?

4. Test enums with int64.

5. Not sure if it's possible, or desirable, but can we overload operators for bitmask and sequence enums to allow comparison with the underlying type? It's still type-safe, but now we don't need to "deref".

  // TODO: Fix splitter, working on adding a filter predicate and perhaps
  // allowing assignment to arbitrary containers.

6. Remove CRTP using "deducing this".

7. Consider adding `final` to classes that really ought to be.

8. meta/containers.h search_and_replace: Consider adding a version that takes parallel arrays for `from` and `to`, replacing all of them. This can't be emulated by nesting.

9. strings/fixed_string_utils.h: Consider writing a version of split that also does a search/replace in parallel (one pass to locate, count, and do the replacements).

10. strings/locating.h substitution/excision improvements:
   a. Substituted and excised don't work for initializer lists. Wrap them.
   b. Excise can always be optimized to do a single pass over the string (locate and copy, skipping the excised parts).
   c. Consider replacing free functions with something more object-oriented (fluent interface or builder pattern).
   d. Benchmark whether it's faster to do replacements in-place or to build a new string with pre-allocated capacity.
   e. If span size is 1, forward to regular locate with pos_value hardcoded to zero, since we know which value it was.

11. strings/conversion.h: Add thorough testing for from_chars_wrap, or replace with a stable third-party library.

12. strings/trimming.h: Determine if there's a safe, correct way to pass through a temporary container without lifetime issues.

13. strings/splitting.h enhancements:
   a. Probably kill the hardcoded vector-only split() overloads that return std::vector.
   b. Consider supporting extended concept where there's a way to register custom splitter behavior.
   c. Write helper in locating.h to take a `location` and return a substring span.
   d. Write split_adapter version that works with any container that can emplace_back.
   e. Implement split_adapter with efficient pre-allocation and single-pass splitting.
   f. Benchmark and optimize single-char delimiter handling.

14. strings/concat_join.h improvements:
   a. Consider adding !Container validation and null key handling in append_join_with for pairs.
   b. Test quote-encoding when a non-string is wrapped in quotes.
   c. Add method that takes pieces and counts up their total (estimated) size for pre-allocation.
   d. Benchmark delim `find` single-char optimizations to verify performance gains.
   e. Consider offering a way to register a tuple-view function for use in formatted output.
   f. Consider offering the reverse of `stream_append_v` for deserialization.

15. containers/own_ptr.h - own_ptr class improvements:
   a. Consider supporting arrays (like std::unique_ptr<T[]>).
   b. Consider supporting interop with `std::shared_ptr`.
   c. Consider allowing specialization to make all operations atomic.

16. containers/arena_allocator.h - extensible_arena class improvements:
   a. Consider adding the ability to limit per-block sizes or total size.
   b. Consider making the next block size constant, even when we had to blow past the limit to accommodate an oversize allocation.
   c. Sufficiently filled should be defined as having less than 1/4 of the capacity free, although it could also be configured.
   d. Consider changing algorithm so that we keep the current block as the head until it's sufficiently filled, overflowing as needed down the chain.

17. containers/custom_handle.h - custom_handle class improvements:
   a. Since move semantics don't work, attempt to allow assignment from a pointer.

18. containers/sync_lock.h - synchronizer class improvements:
   a. Consider adding a safe version of mutex, perhaps based on `std::timed_mutex`, which throws if a lock is not acquired within a certain time.
   b. Consider whether we need an `empty_t` trick to make it easier to specialize the synchronizer away.

19. containers/strong_type.h - strong_type class improvements:
   a. Test use case of nested types, where a T is itself a strong_type on a different tag.
   b. Test use case of a lambda as the underlying type.
   c. Consider changing the requires clauses to AND in a flag that can be specialized, allowing opt-out of operations.

20. containers/timers.h - timers class improvements:
   a. Add method to block until next event is scheduled, which may be pre-empted by the rescheduling of a repeating event or insertion of a new event.
   b. Add poll method that waits until the next event is scheduled or a new event is scheduled. This requires an interruptible wait.
   c. Add clear or reset method to drop all scheduled events. Perhaps add another method to remove all recurring events, optionally sparing them if they've never executed.
   d. Add shutdown tombstone to prevent events from being rescheduled. Wrap it with a method, perhaps a second one that clears recurring.

21. containers/interval.h - interval class improvements:
   a. Consider defaulting `U` to `int64_t` so that it works better when `V` is an enum. Alternately, create something like `as_underlying_t` that maps to a larger size when possible.
   b. Consider storing a closed interval (in interval_iterator) to avoid needing a larger iterator type, merging invalid and empty into a single state.
   c. Consider writing comparison operators and make it work even if their types are different.
   d. In append_fn: Consider printing as half-open interval unless JSON.
   e. In append_fn: Consider printing enum string instead of integer.

22. containers/intern.h improvements:
   a. interned_value::operator==: If the value is itself a view, then we should compare the views. One way would be to compare `begin()`, if it's available.
   b. intern_traits: Add arena size as a parameter.
   c. intern_traits: A deque is only being used for lookup_by_id_ because we want to be able to enlarge without moving. As an optional optimization, write a class with a signature similar to vector or deque that is streamlined to only support appending.
   d. intern_traits: An entirely different scheme would be to store the values in a stable associative container, such as a map, and then use a deque to store pointers into the map.
   e. intern_traits: See if specializations can inherit from the primary template and just replace the types that changed.
   f. intern_table constructor: Consider whether we should disable `next` if it's specified.
   g. intern_table: Add real or fake arena allocator, depending on traits. Then create real or fake scopes in the methods that can allocate.

23. controllers/pid_controller.h - PID controller improvements:
   a. Consider clamping the integral term itself (in addition to final output clamping) for better anti-windup protection. Could default to some fraction of the min and max values.

24. controllers/sopdt_plant.h - SOPTD plant improvements:
   a. Optimize delay buffer with a circular buffer instead of vector erase(begin()) which is O(n).

25. lang/ast_pred.h - AST predicate improvements:
   a. lookup::operator[] is declared but has no implementation and is not pure virtual (= 0). Either make it pure virtual or provide an implementation returning `missing`.
   b. In dnf::handle(), the not_junction case accesses junction::list(root)[0] without bounds checking. If a not_junction is created with zero nodes, this is undefined behavior.
   c. Register the variant types (any_single_value, any_value, key_or_value) for automatic JSON serialization to replace manual dump() helper functions.
   d. Turn tautologies into always_true or always_false nodes. This requires determining if an equality is mutually exclusive, which is trickier for inequalities.

26. enums/bitmask_enum.h - bitmask enum improvements:
   a. Consider making range_length() correct even for validity masks with holes, or at least fail cleanly if we can't.
   b. Consider offering a version of calc_valid_bits_from_bit_names that is aligned to the msb instead of lsb, to avoid forcing the user to pad with dozens of commas.
   c. Offer a binary printer that displays value using single-character names (e.g., "RGB" for white, "R-B" for purple). Needs make_bitmask_enum_binary_spec() that enforces single-char names.
   d. Consider offering a parser to convert string to enum by splitting on "+", trimming spaces, and adding bit values. Consider frozen for compile-time map construction with runtime binary search.
   e. Consider providing operator[] that returns bool for a given index (op version of get_at), plus a proxy object to invoke set_at.
   f. Consider some/all helper functions for readable multi-bit comparisons (e.g., `rgb_yellow == some(rgb::red, rgb::green)`).

27. enums/sequence_enum.h - sequence enum improvements:
   a. Consider specializing std::numeric_limits for sequence enums, inheriting from underlying type and providing correct min/max values.
   b. Consider making an arithmetic_enum variation that allows homogeneous operations for types like std::byte and other strongly-typed integers with full ops support.

28. strings.h - string utility improvements:
   a. Get extract_num to work with cstring_view cleanly. Options: add overloads for extract methods, or add extract_num to cstring class.

29. controllers - controller improvements:
   a. Consider writing a PID auto-tuning class that tunes P, I, D values against a given plant (passed as lambda). Phase 1: increase P until output overshoots. Phase 2: increase I until steady state matches setpoint. Phase 3: tune D to reduce overshoot. Use binary search or gradient descent. Consider ITAE metric and Ziegler-Nichols method.

30. tests - test improvements:
   a. tests/opt_string_view_test.cpp: Add unit tests for optional workalike functions. Consider porting them all to cstring_view.
   b. tests/opt_string_view_test.cpp: Figure out why the && overloads for optional workalike functions don't work.
   c. tests/containers_test.cpp: Follow up on why intern table key can't be a temporary.
   d. tests/containers_test.cpp: Add proper isolated unit tests for arena_allocator.h.
   e. tests/containers_test.cpp: Test arena capacity edge case (small arena, allocate exact capacity, verify second alloc gets new block).
   f. tests/containers_test.cpp: Investigate when traits wrap key in unnecessary indirect_hash_key (affects performance).
   g. tests/containers_test.cpp: Test own_ptr with a move-only pointer type.
   h. tests/containers_test.cpp: Add tests for op->* and more thorough tests for various synchronizer scenarios.
   i. tests/strings_test.cpp: Add rlocate multi-string tests.
   j. tests/strings_test.cpp: Add nested container torture test.
   k. tests/strings_test.cpp: Test plain array, std::array, map, set, pair, tuple.
   l. tests/strings_test.cpp: Test objects that aren't strings but have implicit conversion to string_view.
   m. tests/sequence_enum_test.cpp: Check if enum_as_string works with unscoped enums.
   n. tests/bitmask_enum_test.cpp: Find a way to avoid needing to repeat `rgb` in bitmask enum tests.
   o. tests/bitmask_enum_test.cpp: Add test with make_interval<byte> to show how to use it correctly.
