1. Do all the TODO's scattered throughout the code.
a. Interval needs a major rewrite.
c. concat_join has lots to do. and conversion.h has a related change.
e. string.h has some TODO's.
f. bitmask_enum_tests has some.
g. meta_test has a whole section commented out.
h. strings_test needs more tests.

2. Consider how ostream could be made optional.

3. We need a verson of split that understands quotes and escaping. Maybe just regex and be done with it?

4. Test enums with int64.

5. Not sure if it's possible, or desirable, but can we overload operators for bitmask and sequence enums to allow comparison with the underlying type? It's still type-safe, but now we don't need to "deref".

  // TODO: Fix splitter, working on adding a filter predicate and perhaps
  // allowing assignment to arbitrary containers.

6. Remove CRTP using "deducing this".

7. Consider adding `final` to classes that really ought to be.

8. meta/containers.h search_and_replace: Consider adding a version that takes parallel arrays for `from` and `to`, replacing all of them. This can't be emulated by nesting.

9. strings/fixed_string_utils.h: Consider writing a version of split that also does a search/replace in parallel (one pass to locate, count, and do the replacements).

10. strings/locating.h substitution/excision improvements:
   a. Substituted and excised don't work for initializer lists. Wrap them.
   b. Excise can always be optimized to do a single pass over the string (locate and copy, skipping the excised parts).
   c. Consider replacing free functions with something more object-oriented (fluent interface or builder pattern).
   d. Benchmark whether it's faster to do replacements in-place or to build a new string with pre-allocated capacity.
   e. If span size is 1, forward to regular locate with pos_value hardcoded to zero, since we know which value it was.

11. strings/conversion.h: Add thorough testing for from_chars_wrap, or replace with a stable third-party library.

12. strings/trimming.h: Determine if there's a safe, correct way to pass through a temporary container without lifetime issues.

13. strings/splitting.h enhancements:
   a. Probably kill the hardcoded vector-only split() overloads that return std::vector.
   b. Consider supporting extended concept where there's a way to register custom splitter behavior.
   c. Write helper in locating.h to take a `location` and return a substring span.
   d. Write split_adapter version that works with any container that can emplace_back.
   e. Implement split_adapter with efficient pre-allocation and single-pass splitting.
   f. Benchmark and optimize single-char delimiter handling.

14. strings/concat_join.h improvements:
   a. Consider adding !Container validation and null key handling in append_join_with for pairs.
   b. Test quote-encoding when a non-string is wrapped in quotes.
   c. Add method that takes pieces and counts up their total (estimated) size for pre-allocation.
   d. Benchmark delim `find` single-char optimizations to verify performance gains.
   e. Consider offering a way to register a tuple-view function for use in formatted output.
   f. Consider offering the reverse of `stream_append_v` for deserialization.

15. containers/own_ptr.h - own_ptr class improvements:
   a. Consider supporting arrays (like std::unique_ptr<T[]>).
   b. Consider supporting interop with `std::shared_ptr`.
   c. Consider allowing specialization to make all operations atomic.

16. containers/arena_allocator.h - extensible_arena class improvements:
   a. Consider adding the ability to limit per-block sizes or total size.
   b. Consider making the next block size constant, even when we had to blow past the limit to accommodate an oversize allocation.
   c. Sufficiently filled should be defined as having less than 1/4 of the capacity free, although it could also be configured.
   d. Consider changing algorithm so that we keep the current block as the head until it's sufficiently filled, overflowing as needed down the chain.

17. containers/custom_handle.h - custom_handle class improvements:
   a. Since move semantics don't work, attempt to allow assignment from a pointer.

18. containers/sync_lock.h - synchronizer class improvements:
   a. Consider adding a safe version of mutex, perhaps based on `std::timed_mutex`, which throws if a lock is not acquired within a certain time.
   b. Consider whether we need an `empty_t` trick to make it easier to specialize the synchronizer away.

19. containers/strong_type.h - strong_type class improvements:
   a. Test use case of nested types, where a T is itself a strong_type on a different tag.
   b. Test use case of a lambda as the underlying type.
   c. Consider changing the requires clauses to AND in a flag that can be specialized, allowing opt-out of operations.

20. containers/timers.h - timers class improvements:
   a. Add method to block until next event is scheduled, which may be pre-empted by the rescheduling of a repeating event or insertion of a new event.
   b. Add poll method that waits until the next event is scheduled or a new event is scheduled. This requires an interruptible wait.
   c. Add clear or reset method to drop all scheduled events. Perhaps add another method to remove all recurring events, optionally sparing them if they've never executed.
   d. Add shutdown tombstone to prevent events from being rescheduled. Wrap it with a method, perhaps a second one that clears recurring.

21. containers/interval.h - interval class improvements:
   a. Consider defaulting `U` to `int64_t` so that it works better when `V` is an enum. Alternately, create something like `as_underlying_t` that maps to a larger size when possible.
   b. Consider storing a closed interval (in interval_iterator) to avoid needing a larger iterator type, merging invalid and empty into a single state.
   c. Consider writing comparison operators and make it work even if their types are different.
   d. In append_fn: Consider printing as half-open interval unless JSON.
   e. In append_fn: Consider printing enum string instead of integer.

22. containers/intern.h improvements:
   a. interned_value::operator==: If the value is itself a view, then we should compare the views. One way would be to compare `begin()`, if it's available.
   b. intern_traits: Add arena size as a parameter.
   c. intern_traits: A deque is only being used for lookup_by_id_ because we want to be able to enlarge without moving. As an optional optimization, write a class with a signature similar to vector or deque that is streamlined to only support appending.
   d. intern_traits: An entirely different scheme would be to store the values in a stable associative container, such as a map, and then use a deque to store pointers into the map.
   e. intern_traits: See if specializations can inherit from the primary template and just replace the types that changed.
   f. intern_table constructor: Consider whether we should disable `next` if it's specified.
   g. intern_table: Add real or fake arena allocator, depending on traits. Then create real or fake scopes in the methods that can allocate.
